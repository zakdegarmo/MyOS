<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DungeonNexus9</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
          }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
    </style>
  </head>
  <body class="font-sans">
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, controls, labelRenderer;
        let doors = []; // This will now hold placeholder groups in the correct order
        let hub;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let roomSize;

        // --- NEW: Ordered array of door data ---
        const doorData = [
            { id: 1, model: 'models/glyph_self.glb', link: 'https://zakdegarmo.github.io/MyOntology/' },
            { id: 2, model: 'models/glyph_thought.glb', link: 'https://zakdegarmo.github.io/ZaksNotepad/index.html' },
            { id: 3, model: 'models/glyph_logic.glb', link: '#' }, // Placeholder link
            { id: 4, model: 'models/glyph_unity.glb', link: '#' }, // Placeholder link
            { id: 5, model: 'models/glyph_existence.glb', link: '#' }, // Placeholder link
            { id: 6, model: 'models/glyph_improvement.glb', link: 'https://data-vis-eosin.vercel.app/' },
            { id: 7, model: 'models/glyph_mastery.glb', link: 'https://ai.studio/apps/drive/1XRz8dvokYQyVhmuBG_yMZF4ielHllS2-' },
            { id: 8, model: 'models/glyph_resonance.glb', link: 'https://3d-ttf.vercel.app/' },
            { id: 9, model: 'models/glyph_transcendence.glb', link: 'https:hyper-aether-pilgrim.vercel.app/' }
        ];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.005);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            roomSize = 250;
            const skyboxGeometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize, 10, 10, 10);
            const skyboxMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true, side: THREE.BackSide });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);

            const floorSize = roomSize * 2;
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -(roomSize / 2);
            scene.add(floor);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, roomSize * 0.4);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = roomSize * 0.8;
            controls.target.set(0, -(roomSize / 2) + 15, 0);

            const ambientLight = new THREE.AmbientLight(0x444444, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.5, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            const hubGeometry = new THREE.IcosahedronGeometry(15, 3);
            const hubMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
            hub = new THREE.Mesh(hubGeometry, hubMaterial);
            const hubHeight = 15 * 2;
            const hoverOffset = 5;
            hub.position.y = -(roomSize / 2) + (hubHeight / 2) + hoverOffset;
            hub.userData = { id: 0, name: "Back to Previous" };
            scene.add(hub);
            
            createDoors();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
        }

        function createDoors() {
            const loader = new GLTFLoader();
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2,
                wireframe: true
            });

            doorData.forEach((data, i) => {
                // Create a placeholder group for each door immediately to preserve order
                const doorGroup = new THREE.Group();
                doorGroup.userData = { id: data.id, link: data.link };
                
                doors.push(doorGroup); // Add placeholder to the main array
                scene.add(doorGroup);

                loader.load(data.model, (gltf) => {
                    const model = gltf.scene;
                    
                    // Apply material and scale to the loaded model
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = doorMaterial;
                        }
                    });
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 20 / Math.max(size.x, size.y, size.z);
                    model.scale.set(scale, scale, scale);
                    
                    // Add the loaded model to its placeholder group
                    doorGroup.add(model);
                });
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onClick(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let selectedObject = intersects[0].object;
                // Traverse up to find the parent group with the link and ID
                while (selectedObject.parent && !selectedObject.userData.link) {
                    selectedObject = selectedObject.parent;
                }
                
                const { id, link } = selectedObject.userData;

                if (id === 0) {
                    setTimeout(() => { window.history.back(); }, 500);
                } else if (link && link !== '#') {
                    window.location.href = link;
                } else {
                    console.log(`Clicked on Portal ${id}, but no link is assigned.`);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.0005;
            
            // Animate the placeholder groups, which will move the models once they load
            doors.forEach((doorGroup, i) => {
                const angle = time * 0.5 + (i / doorData.length) * Math.PI * 2;
                const doorRadius = roomSize * 0.4;
                const doorHeight = 30;
                const hoverOffset = 5;
                
                doorGroup.position.x = Math.cos(angle) * doorRadius;
                doorGroup.position.z = Math.sin(angle) * doorRadius;
                doorGroup.position.y = -(roomSize / 2) + (doorHeight / 2) + hoverOffset + Math.sin(angle * 2.5 + i) * 5;
                doorGroup.lookAt(hub.position);

                const pulseScale = 1 + Math.sin(time * 5 + i) * 0.02;
                // Check if the model has loaded before trying to set its scale
                if (doorGroup.children.length > 0) {
                    doorGroup.children[0].scale.set(pulseScale, pulseScale, pulseScale);
                }
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
        animate();
    </script>
  </body>
</html>
