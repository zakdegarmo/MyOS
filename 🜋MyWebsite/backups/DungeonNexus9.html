<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prime Nexus - FileSlayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
  }
}
</script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
    </style>
  </head>
  <body class="font-sans">
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js'; // For labels

        let camera, scene, renderer, controls, labelRenderer;
        let doors = [];
        let hub;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Declare roomSize globally so it's accessible in animate()
        let roomSize; 

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.005); // Fog matches new black background

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Label Renderer for 2D HTML labels
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through
            document.body.appendChild(labelRenderer.domElement);

            // --- Skybox: Wireframe Dungeon Walls (Rescaled to room size) ---
            roomSize = 250; // Increased size for a more spacious room
            const skyboxGeometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize, 10, 10, 10);
            const skyboxMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Yellow wireframe
                wireframe: true,
                side: THREE.BackSide // Render inside the box
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);

            // --- Floor Plane ---
            // Sized to be twice as large as the room, and positioned at the bottom edge
            const floorSize = roomSize * 2; // Floor is twice the size of the room
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
            const floorMaterial = new THREE.MeshBasicMaterial({
                color: 0x808080, // Solid gray color
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -(roomSize / 2); // Position at the bottom edge of the skybox
            scene.add(floor);

            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, roomSize * 0.4); // Adjusted camera position relative to room size

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = roomSize * 0.8; // Max distance relative to room size
            controls.autoRotate = false;
            // Set controls target to look slightly down towards the floor
            controls.target.set(0, -(roomSize / 2) + 15, 0); // Aim slightly above the floor

            // Lights (Subtle for wireframe aesthetic)
            const ambientLight = new THREE.AmbientLight(0x444444, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.5, 1000);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Central Hub (Back Button) - Wireframe Yellow
            const hubGeometry = new THREE.IcosahedronGeometry(15, 3);
            const hubMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Yellow
                wireframe: true // Wireframe
            });
            hub = new THREE.Mesh(hubGeometry, hubMaterial);
            // Position hub just above the floor
            const hubHeight = 15 * 2; // Radius * 2
            const hoverOffset = 5; // Small offset to hover above floor
            hub.position.y = -(roomSize / 2) + (hubHeight / 2) + hoverOffset; 
            hub.userData = { id: 0, name: "Back to Previous", description: "Return to the last visited location." };
            scene.add(hub);
            
            // Create Doors (Portals) - Wireframe Yellow with vertical lines
            const doorCount = 9;
            const doorGeometry = new THREE.PlaneGeometry(20, 30, 5, 1);
            const doorMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // Yellow
                wireframe: true,
                side: THREE.DoubleSide
            });

            for (let i = 0; i < doorCount; i++) {
                const door = new THREE.Mesh(doorGeometry, doorMaterial.clone());
                
                const angle = (i / doorCount) * Math.PI * 2;
                const doorRadius = roomSize * 0.4; // Doors rotate near the outside edge of the room
                const x = Math.cos(angle) * doorRadius;
                // Position doors just above the floor
                const doorHeight = 30; // Height of PlaneGeometry
                const y = -(roomSize / 2) + (doorHeight / 2) + hoverOffset + Math.sin(angle * 2.5 + i) * 5; // Add bobbing
                const z = Math.sin(angle) * doorRadius;

                door.position.set(x, y, z);
                door.lookAt(hub.position);
                door.rotation.y += Math.PI / 2;
                door.userData = { id: i + 1, name: `Portal ${i + 1}`, description: `Enter NLBL${i + 1} Dungeon.` };
                doors.push(door);
                scene.add(door);

                // Add number label using CSS2DObject
                const doorLabelDiv = document.createElement('div');
                doorLabelDiv.className = 'door-label text-white text-3xl font-bold';
                doorLabelDiv.textContent = `${i + 1}`;
                doorLabelDiv.style.textShadow = '0px 0px 10px rgba(255,255,0,0.8)';
                doorLabelDiv.style.color = '#FFFF00';

                const doorLabel = new CSS2DObject(doorLabelDiv);
                doorLabel.position.set(0, 0, 1);
                door.add(doorLabel);
            }

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
            document.addEventListener('mousemove', onMouseMove);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...doors, hub]);
        }
function onClick(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects([...doors, hub]);
    
    if (intersects.length > 0) {
        const selectedObject = intersects[0].object;
        const { id, name, description } = selectedObject.userData;

        if (id === 0) { // Central Hub (Back Button)
            console.log("Attempting to go back...");
            setTimeout(() => {
                window.history.back();
            }, 500);
        } else if (id === 1) { // Link for the MyOntology GitHub Page
            console.log(`Clicked on ${name}: ${description}`);
            window.location.href = "https://zakdegarmo.github.io/MyOntology/";
        }  else if (id === 6) { // This is the logic for the dataVis project
            console.log(`Clicked on ${name}: ${description}`);
            window.location.href = "https://data-vis-eosin.vercel.app/";
        } else if (id === 7) { // This is the new logic for the 3d-atom-visualizer project
            console.log(`Clicked on ${name}: ${description}`);
            window.location.href = "https://ai.studio/apps/drive/1XRz8dvokYQyVhmuBG_yMZF4ielHllS2-";
        } else if (id === 9) { // This is the logic for the HAP project
            console.log(`Clicked on ${name}: ${description}`);
            window.location.href = "https://hyper-aether-pilgrim-4yu6.vercel.app/";
        } else { // All other doors (Portals)
            console.log(`Clicked on ${name}: ${description}`);
        }
    }
}        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.0005;
            
            doors.forEach((door, i) => {
                const angle = time * 0.5 + (i / doors.length) * Math.PI * 2;
                const doorRadius = roomSize * 0.4; 
                const doorHeight = 30; // Height of PlaneGeometry
                const hoverOffset = 5; // Small offset to hover above floor
                // Recalculate y position for animation to ensure it stays above the floor
                door.position.x = Math.cos(angle) * doorRadius;
                door.position.z = Math.sin(angle) * doorRadius;
                door.position.y = -(roomSize / 2) + (doorHeight / 2) + hoverOffset + Math.sin(angle * 2.5 + i) * 5;
                door.lookAt(hub.position);

                // Subtle pulsing animation for doors (applied to scale)
                const pulseScale = 1 + Math.sin(time * 5 + i) * 0.02;
                door.scale.set(pulseScale, pulseScale, pulseScale);
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
        animate();
    </script>
  </body>
</html>
